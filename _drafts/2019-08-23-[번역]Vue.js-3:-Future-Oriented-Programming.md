---
layout: post
title: "[번역]Vue.js 3: Future-Oriented Programming"
author: "genie-youn"
categories: journal
tags: [vue]
image: jakub-kapusnak-Rt2t11IUizs-unsplash.jpg
---
이 글은 [Vue.js 3: Future-Oriented Programming](https://blog.bitsrc.io/vue-js-3-future-oriented-programming-54dee797988b)를 원저자의 허락을 받아 번역하였습니다.

Vue.js에 관심을 가지고 있다면 아마 곧 3번째 버전이 출시된다는 것을 알고 있을것이다. (미래에 이 글을 읽고 있다면, 이 글이 여전히 유효하기를 바란다. 😉)

활발하게 개발되고 있는 새로운 버전의 기능들은 다음 [레파지토리](https://github.com/vuejs/rfcs)의 RFC(request for comments)를 통해 확인할 수 있다. 그 중 하나인 functional-api는 Vue 어플리케이션을 개발하는 방식에 드라마틱한 변화를 가져올것 같다.

> 이 글은 JavaScript와 Vue에 관하여 어느정도 사전지식을 가지고 있다고 가정하고 쓰여졌다.

Before we start: Use Bit to encapsulate Vue components with all their dependencies and setup. Build truly modular applications with better code reuse, simpler maintenance and less overhead. Share and collaborate on individual Vue components.

(광고) 시작하기 전에, Bit을 사용하면 Vue 컴포넌트를 의존하고 있는 모듈들과 함께 캡슐화 할 수 있습니다. 이는 더 쉽게 코드를 재사용하고 유지보수하며 더 적은 오버헤드를 갖도록 잘 모듈화 된 애플리케이션을 설계하는걸 돕습니다. **Bit을 이용하여 독립작인 Vue 컴포넌트를 공유하여 협업하세요.**

![bit](https://blog.bitsrc.io/vue-js-3-future-oriented-programming-54dee797988b)

## 현재 API들의 문제
이해를 돕는 가장 좋은 방법은 예제를 보는것이니, 예제를 살펴보도록 하자. 유저의 데이터를 API로 부터 받아오고, 그 동안 로딩중이라는 상태를 표시하고 스크롤의 높이에 따라 변하는 헤더를 가진 컴포넌트를 구현해야 한다고 생각해보자. 아마 이렇게 생긴?

![result](https://blog.bitsrc.io/vue-js-3-future-oriented-programming-54dee797988b)

실제로 동작하는 예제는 [이 곳](https://enkot.github.io/vue-function-api-test/)에서 볼 수 있다.

여러 컴포넌트에서 재사용될 수 있는 로직은 추출하는것이 좋다. 현재 Vue 2.x의 API에서는 잘 알려진 몇가지 패턴이 있다.

- 믹스인 (`mixins` 옵션)
- 고차<sup>Higer-order</sup> 컴포넌트 (HOCs)

So, let’s move scroll tracking logic into a mixin, and fetching logic into a higher-order component. Typical implementation with Vue you can see below.

스크롤의 위치를 쫓는 로직은 믹스인으로, 데이터를 가져오는 로직은 고차 컴포넌트로 옮겨보자. 일반적인 구현은 다음과 같을것이다.

Scroll Mixin:
```JavaScript
const scrollMixin = {
    data() {
        return {
            pageOffset: 0
        }
    },
    mounted() {
        window.addEventListener('scroll', this.update)
    },
    destroyed() {
        window.removeEventListener('scroll', this.update)
    },
    methods: {
        update() {
            this.pageOffset = window.pageYOffset
        }
    }
}
```

여기서 스크롤 이벤트에 리스너를 추가하고, 페이지의 offset을 따라 `pageOffset`이라는 프로퍼티에 이 값을 저장한다.

고차 <sup>higer-order</sup> 컴포넌트는 다음과 같이 구현할 수 있다.

```javascript
import { fetchUserPosts } from '@/api'

const withPostsHOC = WrappedComponent => ({
    props: WrappedComponent.props,
    data() {
        return {
            postsIsLoading: false,
            fetchedPosts: []
        }
    },
    watch: {
        id: {
            handler: 'fetchPosts',
            immediate: true
        }
    },
    methods: {
        async fetchPosts() {
            this.postsIsLoading = true
            this.fetchedPosts = await fetchUserPosts(this.id)
            this.postsIsLoading = false
        }
    },
    computed: {
        postsCount() {
            return this.fetchedPosts.length
        }
    },
    render(h) {
        return h(WrappedComponent, {
            props: {
                ...this.$props,
                isLoading: this.postsIsLoading,
                posts: this.fetchedPosts,
                count: this.postsCount
            }
        })
    }
})
```

여기서 `isLoading`, `posts` 프로퍼티는 각각 로딩 상태와 유저의 포스트에 관한 데이터로 초기화된다.
`fetchPosts` 메소드는 인스턴스가 생성된 후 `props.id`의 값이 변경될 때 마다 새로운 `id`를 가진 유저의 포스트를 가져오기 위해 호출된다.

위 코드는 HOC의 완전한 구현은 아니지만, 이 예제에는 충분할 것이다.
여기서 우리는 특정 컴포넌트를 감싸서 컴포넌트의 프로퍼티와 데이터를 가져오는것과 관련된 프로퍼티를 함께 전달한다.

감싸지는 컴포넌트는 다음과 같다.

```JavaScript
export default {
    name: 'PostsPage',
    mixins: [scrollMixin],
    props: {
        id: Number,
        isLoading: Boolean,
        posts: Array,
        count: Number
    }
}
```

해당 프로퍼티에 접근하려면 HOC로 감싸야 한다.

`const PostsPage = withPostsHOC(PostsPage)`
> 해당 컴포넌트의 전체 코드는 [여기](https://github.com/enkot/vue-function-api-test/blob/master/src/components/PostsPageOptions.vue)서 확인하시면 됩니다.

이제 우리는 특정 로직을 믹스인과 고차 컴포넌트를 통해 구현했으므로 다른 그 어떤 컴포넌트에서도 재사용 될 수 있다. 🥳 그러나 모든것이 장미빛은 아니다. 이 접근법들에는 몇가지 문제가 존재한다.

### 1. 네임스페이스의 충돌 ⚔️

`PostPage` 컴포넌트에 `update` 라는 메소드를 추가해야한다고 생각해보자.
```JavaScript
export default {
    name: 'PostsPage',
    mixins: [scrollMixin],
    props: {
        id: Number,
        isLoading: Boolean,
        posts: Array,
        count: Number
    },
    methods: {
        update() {
            console.log('some update logic here')
        }
    }
}
```

페이지를 다시 열고 스크롤을 하게 되면, 상단 영역은 더 이상 보여지지 않는다. 우리가 추가한 메소드가 믹스인의 `update` 메소드를 덮어쓰기 때문이다.

고차 컴포넌트에서도 마찬가지이다. 만약 `data`의 `fetchedPosts`를 `posts`로 변경하게 되면 문제가 발생하게 된다.


```JavaScript
const withPostsHOC = WrappedComponent => ({
    props: WrappedComponent.props, // ['posts', ...]
    data() {
        return {
            postsIsLoading: false,
            posts: [] // fetchedPosts -> posts
        }
    },
```

아마 이런 에러를 보게 될 것이다.

이미지

그 이유는 감싸려고 했던 컴포넌트가 이미 `posts` 라는 이름의 프로퍼티를 사용하고 있기 때문이다.

### 2. 명확하지 않은 출처 📦
얼마 후에 이 컴포넌트에 다른 믹스인을 사용해야겠다고 결심한다면 어떻게 될까?

```JavaScript
export default {
    name: 'PostsPage',
    mixins: [scrollMixin, mouseMixin],
```

이 코드를 보고 `pageOffset` 프로퍼티가 어느 믹스인으로부터 주입되었는지 정확히 설명할수 있는가? 또는 두 믹스인 모두 `yOffset` 프로퍼티를 가질수도 있다. 이럴 경우 마지막 믹스인이 이전 믹스인에 정의되어 있던 `yOffset` 프로퍼티를 오버라이드 하게된다. 이는 좋은 코드가 아니며 때로는 예상치 못한 많은 버그를 만들어 낼지도 모른다. 😕

### 3. 성능 ⏱

고차 컴포넌트의 또다른 문제는 단지 비즈니스 로직을 재사용하기 위한 목적의 별개의 컴포넌트 인스턴스를 생성해야한다는 것이고, 이 또한 비용임을 명심해야 한다.

## 준비 🏗

똑같은 문제를 다음 버전에서 제공될 `function-based API` 를 통해 해결해 보자.

Vue3는 아직 릴리즈되지 않았지만, `vue-function-api` 라는 플러그인을 통해 2.x에서도 3.x의 함수형 API를 사용할 수 있다.

우선 이 플러그인을 설치해야 한다.
`$ npm install vue-function-api`

그런다음 `Vue.use()`를 통해 이 플러그인을 설치할것을 명시한다.

```JavaScript
import Vue from 'vue'
import { plugin } from 'vue-function-api'

Vue.use(plugin)
```
